{"version":3,"file":"index.c33c7dbe.js","sources":["../../../node_modules/just-curry-it/index.js","../../../node_modules/content-type/index.js","../../../node_modules/@hyperjump/browser/url-resolve-browser/index.js","../../../node_modules/@hyperjump/browser/fetch.browser.js","../../../node_modules/@hyperjump/browser/common.js","../../../node_modules/@hyperjump/browser/core.js","../../../node_modules/@hyperjump/browser/json/core.js","../../../node_modules/@hyperjump/browser/json/index.js","../../../node_modules/@hyperjump/json-pointer/json-pointer.js","../../../node_modules/@hyperjump/browser/json-reference/core.js","../../../node_modules/@hyperjump/browser/json-reference/index.js","../../../node_modules/@hyperjump/browser/index.js","../../../node_modules/@hyperjump/validation/node_modules/just-curry-it/index.js","../../../node_modules/@hyperjump/validation/node_modules/content-type/index.js","../../../node_modules/@hyperjump/validation/node_modules/@hyperjump/browser/url-resolve-browser/index.js","../../../node_modules/@hyperjump/validation/node_modules/@hyperjump/browser/fetch.browser.js","../../../node_modules/@hyperjump/validation/node_modules/@hyperjump/browser/common.js","../../../node_modules/@hyperjump/validation/node_modules/@hyperjump/browser/core.js","../../../node_modules/@hyperjump/validation/node_modules/@hyperjump/browser/json/core.js","../../../node_modules/@hyperjump/validation/node_modules/@hyperjump/browser/json/index.js","../../../node_modules/@hyperjump/validation/node_modules/@hyperjump/json-pointer/json-pointer.js","../../../node_modules/@hyperjump/validation/node_modules/@hyperjump/browser/json-reference/core.js","../../../node_modules/@hyperjump/validation/node_modules/@hyperjump/browser/json-reference/index.js","../../../node_modules/@hyperjump/validation/node_modules/@hyperjump/browser/index.js","../../../node_modules/@hyperjump/validation/node_modules/fastestsmallesttextencoderdecoder/NodeJS/EncoderAndDecoderNodeJS.src.js","../../../node_modules/@hyperjump/validation/lib/common.js","../../../node_modules/@hyperjump/validation/lib/core.js","../../../node_modules/@hyperjump/validation/node_modules/fastest-stable-stringify/index.js","../../../node_modules/@hyperjump/validation/lib/keywords/common/const.js","../../../node_modules/@hyperjump/validation/lib/keywords/common/type.js","../../../node_modules/@hyperjump/validation/lib/keywords/common/multipleOf.js","../../../node_modules/@hyperjump/validation/lib/keywords/common/maximum.js","../../../node_modules/@hyperjump/validation/lib/keywords/common/exclusiveMaximum.js","../../../node_modules/@hyperjump/validation/lib/keywords/common/minimum.js","../../../node_modules/@hyperjump/validation/lib/keywords/common/exclusiveMinimum.js","../../../node_modules/@hyperjump/validation/lib/keywords/common/maxLength.js","../../../node_modules/@hyperjump/validation/lib/keywords/common/minLength.js","../../../node_modules/@hyperjump/validation/lib/keywords/common/pattern.js","../../../node_modules/@hyperjump/validation/lib/keywords/common/items.js","../../../node_modules/@hyperjump/validation/lib/keywords/common/tupleItems.js","../../../node_modules/@hyperjump/validation/lib/keywords/common/maxItems.js","../../../node_modules/@hyperjump/validation/lib/keywords/common/minItems.js","../../../node_modules/@hyperjump/validation/lib/keywords/common/uniqueItems.js","../../../node_modules/@hyperjump/validation/lib/keywords/common/properties.js","../../../node_modules/@hyperjump/validation/lib/keywords/common/patternProperties.js","../../../node_modules/@hyperjump/validation/lib/keywords/common/propertyNames.js","../../../node_modules/@hyperjump/validation/lib/keywords/common/maxProperties.js","../../../node_modules/@hyperjump/validation/lib/keywords/common/minProperties.js","../../../node_modules/@hyperjump/validation/lib/keywords/common/required.js","../../../node_modules/@hyperjump/validation/lib/keywords/common/allOf.js","../../../node_modules/@hyperjump/validation/lib/keywords/common/anyOf.js","../../../node_modules/@hyperjump/validation/lib/keywords/common/oneOf.js","../../../node_modules/@hyperjump/validation/lib/keywords/common/not.js","../../../node_modules/@hyperjump/validation/lib/keywords/common/definitions.js","../../../node_modules/@hyperjump/validation/lib/keywords/common/validation.js","../../../node_modules/@hyperjump/validation/lib/index.js","../../../src/routes/index.svelte"],"sourcesContent":["module.exports = curry;\n\n/*\n  function add(a, b, c) {\n    return a + b + c;\n  }\n  curry(add)(1)(2)(3); // 6\n  curry(add)(1)(2)(2); // 5\n  curry(add)(2)(4, 3); // 9\n\n  function add(...args) {\n    return args.reduce((sum, n) => sum + n, 0)\n  }\n  var curryAdd4 = curry(add, 4)\n  curryAdd4(1)(2, 3)(4); // 10\n\n  function converter(ratio, input) {\n    return (input*ratio).toFixed(1);\n  }\n  const curriedConverter = curry(converter)\n  const milesToKm = curriedConverter(1.62);\n  milesToKm(35); // 56.7\n  milesToKm(10); // 16.2\n*/\n\nfunction curry(fn, arity) {\n  return function curried() {\n    if (arity == null) {\n      arity = fn.length;\n    }\n    var args = [].slice.call(arguments);\n    if (args.length >= arity) {\n      return fn.apply(this, args);\n    } else {\n      return function() {\n        return curried.apply(this, args.concat([].slice.call(arguments)));\n      };\n    }\n  };\n}\n","/*!\n * content-type\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * RegExp to match *( \";\" parameter ) in RFC 7231 sec 3.1.1.1\n *\n * parameter     = token \"=\" ( token / quoted-string )\n * token         = 1*tchar\n * tchar         = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n *               / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n *               / DIGIT / ALPHA\n *               ; any VCHAR, except delimiters\n * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE\n * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text\n * obs-text      = %x80-FF\n * quoted-pair   = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n */\nvar PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *(\"(?:[\\u000b\\u0020\\u0021\\u0023-\\u005b\\u005d-\\u007e\\u0080-\\u00ff]|\\\\[\\u000b\\u0020-\\u00ff])*\"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g\nvar TEXT_REGEXP = /^[\\u000b\\u0020-\\u007e\\u0080-\\u00ff]+$/\nvar TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/\n\n/**\n * RegExp to match quoted-pair in RFC 7230 sec 3.2.6\n *\n * quoted-pair = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n * obs-text    = %x80-FF\n */\nvar QESC_REGEXP = /\\\\([\\u000b\\u0020-\\u00ff])/g\n\n/**\n * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6\n */\nvar QUOTE_REGEXP = /([\\\\\"])/g\n\n/**\n * RegExp to match type in RFC 7231 sec 3.1.1.1\n *\n * media-type = type \"/\" subtype\n * type       = token\n * subtype    = token\n */\nvar TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/\n\n/**\n * Module exports.\n * @public\n */\n\nexports.format = format\nexports.parse = parse\n\n/**\n * Format object to media type.\n *\n * @param {object} obj\n * @return {string}\n * @public\n */\n\nfunction format (obj) {\n  if (!obj || typeof obj !== 'object') {\n    throw new TypeError('argument obj is required')\n  }\n\n  var parameters = obj.parameters\n  var type = obj.type\n\n  if (!type || !TYPE_REGEXP.test(type)) {\n    throw new TypeError('invalid type')\n  }\n\n  var string = type\n\n  // append parameters\n  if (parameters && typeof parameters === 'object') {\n    var param\n    var params = Object.keys(parameters).sort()\n\n    for (var i = 0; i < params.length; i++) {\n      param = params[i]\n\n      if (!TOKEN_REGEXP.test(param)) {\n        throw new TypeError('invalid parameter name')\n      }\n\n      string += '; ' + param + '=' + qstring(parameters[param])\n    }\n  }\n\n  return string\n}\n\n/**\n * Parse media type to object.\n *\n * @param {string|object} string\n * @return {Object}\n * @public\n */\n\nfunction parse (string) {\n  if (!string) {\n    throw new TypeError('argument string is required')\n  }\n\n  // support req/res-like objects as argument\n  var header = typeof string === 'object'\n    ? getcontenttype(string)\n    : string\n\n  if (typeof header !== 'string') {\n    throw new TypeError('argument string is required to be a string')\n  }\n\n  var index = header.indexOf(';')\n  var type = index !== -1\n    ? header.substr(0, index).trim()\n    : header.trim()\n\n  if (!TYPE_REGEXP.test(type)) {\n    throw new TypeError('invalid media type')\n  }\n\n  var obj = new ContentType(type.toLowerCase())\n\n  // parse parameters\n  if (index !== -1) {\n    var key\n    var match\n    var value\n\n    PARAM_REGEXP.lastIndex = index\n\n    while ((match = PARAM_REGEXP.exec(header))) {\n      if (match.index !== index) {\n        throw new TypeError('invalid parameter format')\n      }\n\n      index += match[0].length\n      key = match[1].toLowerCase()\n      value = match[2]\n\n      if (value[0] === '\"') {\n        // remove quotes and escapes\n        value = value\n          .substr(1, value.length - 2)\n          .replace(QESC_REGEXP, '$1')\n      }\n\n      obj.parameters[key] = value\n    }\n\n    if (index !== header.length) {\n      throw new TypeError('invalid parameter format')\n    }\n  }\n\n  return obj\n}\n\n/**\n * Get content-type from req/res objects.\n *\n * @param {object}\n * @return {Object}\n * @private\n */\n\nfunction getcontenttype (obj) {\n  var header\n\n  if (typeof obj.getHeader === 'function') {\n    // res-like\n    header = obj.getHeader('content-type')\n  } else if (typeof obj.headers === 'object') {\n    // req-like\n    header = obj.headers && obj.headers['content-type']\n  }\n\n  if (typeof header !== 'string') {\n    throw new TypeError('content-type header is missing from object')\n  }\n\n  return header\n}\n\n/**\n * Quote a string if necessary.\n *\n * @param {string} val\n * @return {string}\n * @private\n */\n\nfunction qstring (val) {\n  var str = String(val)\n\n  // no need to quote tokens\n  if (TOKEN_REGEXP.test(str)) {\n    return str\n  }\n\n  if (str.length > 0 && !TEXT_REGEXP.test(str)) {\n    throw new TypeError('invalid parameter value')\n  }\n\n  return '\"' + str.replace(QUOTE_REGEXP, '\\\\$1') + '\"'\n}\n\n/**\n * Class to represent a content type.\n * @private\n */\nfunction ContentType (type) {\n  this.parameters = Object.create(null)\n  this.type = type\n}\n","/* eslint-disable */\n'use strict';\nmodule.exports = urlResolve;\n\n/*\nThe majority of the module is built by following RFC1808\nurl: https://tools.ietf.org/html/rfc1808\n*/\n\n// adds a slash at end if not present\nfunction _addSlash (url) {\n  return url + (url[url.length-1] === '/' ? '' : '/');\n}\n\n// resolve the ..'s (directory up) and such\nfunction _pathResolve (path) {\n  let pathSplit = path.split('/');\n\n  // happens when path starts with /\n  if (pathSplit[0] === '') {\n    pathSplit = pathSplit.slice(1);\n  }\n\n  // let segmentCount = 0; // number of segments that have been passed\n  let resultArray = [];\n  pathSplit.forEach((current, index) => {\n    // skip occurances of '.'\n    if (current !== '.') {\n      if (current === '..') {\n        resultArray.pop(); // remove previous\n      } else if (current !== '') {\n        resultArray.push(current);\n      }\n    }\n  });\n  return '/' + resultArray.join('/');\n}\n\n// parses a base url string into an object containing host, path and query\nfunction _baseParse (base) {\n  const resultObject = {\n    host: '',\n    path: '',\n    query: '',\n    protocol: ''\n  };\n\n  let path = base;\n  let protocolEndIndex = base.indexOf('//');\n\n  if (protocolEndIndex === -1) {\n    throw new Error('Error, protocol is not specified');\n  }\n\n  resultObject.protocol = path.substring(0, protocolEndIndex);\n\n  protocolEndIndex += 2; // add two to pass double slash\n\n  const pathIndex = base.indexOf('/', protocolEndIndex);\n  const queryIndex = base.indexOf('?');\n  const hashIndex = base.indexOf('#');\n\n  if (hashIndex !== -1) {\n    path = path.substring(0, hashIndex); // remove hash, not needed for base\n  }\n\n  if (queryIndex !== -1) {\n    const query = path.substring(queryIndex); // remove query, save in return obj\n    resultObject.query = query;\n    path = path.substring(0, queryIndex);\n  }\n\n  if (pathIndex !== -1) {\n    const host = path.substring(0, pathIndex); // separate host & path\n    resultObject.host = host;\n    path = path.substring(pathIndex);\n    resultObject.path = path;\n  } else {\n    resultObject.host = path; // there was no path, therefore path is host\n  }\n\n  return resultObject;\n}\n\nfunction _isAbsolute(relative) {\n  // https://tools.ietf.org/html/rfc3986#section-3.1\n  const scheme = '[a-z][a-z0-9+.-]*'; // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\"  )]\n  const isAbsolutePattern = new RegExp(`^(${scheme}:)?//`, 'i');\n  return isAbsolutePattern.test(relative);\n}\n\n// parses a relative url string into an object containing the href,\n// hash, query and whether it is a net path, absolute path or relative path\nfunction _relativeParse (relative) {\n  const resultObject = {\n    href: relative, // href is always what was passed through\n    hash: '',\n    query: '',\n    netPath: false,\n    absolutePath: false,\n    relativePath: false\n  };\n  // check for protocol\n  // if protocol exists, is net path (absolute URL)\n  if (_isAbsolute(relative)) {\n    resultObject.netPath = true;\n    // return, in this case the relative is the resolved url, no need to parse.\n    return resultObject;\n  }\n\n  // if / is first, this is an absolute path,\n  // I.E. it overwrites the base URL's path\n  if (relative[0] === '/') {\n    resultObject.absolutePath = true;\n    // return resultObject\n  } else {\n    resultObject.relativePath = true;\n  }\n\n  let path = relative;\n  const queryIndex = relative.indexOf('?');\n  const hashIndex = relative.indexOf('#');\n\n  if (hashIndex !== -1) {\n    const hash = path.substring(hashIndex);\n    resultObject.hash = hash;\n    path = path.substring(0, hashIndex);\n  }\n\n  if (queryIndex !== -1) {\n    const query = path.substring(queryIndex);\n    resultObject.query = query;\n    path = path.substring(0, queryIndex);\n  }\n\n  resultObject.path = path; // whatever is left is path\n  return resultObject;\n}\n\nfunction _shouldAddSlash (url) {\n  const protocolIndex = url.indexOf('//') + 2;\n  const noPath = !(url.includes('/', protocolIndex));\n  const noQuery = !(url.includes('?', protocolIndex));\n  const noHash = !(url.includes('#', protocolIndex));\n  return (noPath && noQuery && noHash);\n}\n\nfunction _shouldAddProtocol (url) {\n  return url.startsWith('//');\n}\n\n/*\n* PRECONDITION: Base is a fully qualified URL. e.g. http://example.com/\n* optional: path, query or hash\n* returns the resolved url\n*/\nfunction urlResolve (base, relative) {\n  base = base.trim();\n  relative = relative.trim();\n\n  // about is always absolute\n  if (relative.startsWith('about:')) {\n    return relative;\n  }\n\n  // if base is empty, assume relative is a net path.\n  if (base === '') {\n    if (_shouldAddSlash(relative)) {\n      return _addSlash(relative);\n    }\n    // add / at end if not present if is only the host\n    return relative;\n  }\n  const baseObj = _baseParse(base);\n  // relative is empty, return base minus hash\n  if (relative === '') {\n    const {host, path, query} = baseObj;\n    // when path and query aren't supplied add slash\n    if ((!path) && (!query)) {\n      return _addSlash(host);\n    }\n    return host + path + query;\n  }\n\n  const relativeObj = _relativeParse(relative);\n\n  if (relativeObj.netPath) { // relative is full qualified URL\n    if (_shouldAddProtocol(relativeObj.href)) {\n      relativeObj.href = baseObj.protocol + relativeObj.href;\n    }\n\n    if (_shouldAddSlash(relativeObj.href)) {\n      return _addSlash(relativeObj.href);\n    }\n\n    return relativeObj.href;\n  } else if (relativeObj.absolutePath) { // relative is an absolute path\n    const {path, query, hash} = relativeObj;\n\n    return baseObj.host + _pathResolve(path) + query + hash;\n  } else if (relativeObj.relativePath) { // relative is a relative path\n    const {path, query, hash} = relativeObj;\n\n    let basePath = baseObj.path;\n    let resultString = baseObj.host;\n\n    let resolvePath;\n\n    if (path.length === 0) {\n      resolvePath = basePath;\n    } else {\n      // remove last segment if no slash at end\n      basePath = basePath.substring(0, basePath.lastIndexOf('/'));\n      resolvePath = _pathResolve(basePath + '/' + path);\n    }\n\n    // if result is just the base host, add /\n    if ((resolvePath === '') && (!query) && (!hash)) {\n      resultString += '/';\n    } else {\n      resultString += resolvePath + query + hash;\n    }\n\n    return resultString;\n  }\n}\n","module.exports = fetch;\n","const uriReference = (url) => url.split(\"#\", 1)[0];\nconst uriFragment = (url) => url.split(\"#\", 2)[1] || \"\";\nconst isObject = (value) => typeof value === \"object\" && !Array.isArray(value) && value !== null;\n\nmodule.exports = { uriReference, uriFragment, isObject };\n","const curry = require(\"just-curry-it\");\nconst contentTypeParser = require(\"content-type\");\nconst resolveUrl = require(\"./url-resolve-browser\");\nconst fetch = require(\"./fetch\");\nconst { uriReference, isObject } = require(\"./common\");\n\n\nconst construct = (url, headers, body) => Object.freeze({ url, headers, body });\nconst extend = (doc, extras) => Object.freeze({ ...doc, ...extras });\n\nconst nil = construct(\"\", {}, undefined);\nconst source = (doc) => doc.body;\nconst value = (doc) => isDocument(doc) ? contentTypeHandler(doc).value(doc) : doc;\n\nconst get = curry(async (url, contextDoc, options = {}) => {\n  let result;\n  const doc = await contextDoc;\n  const resolvedUrl = resolveUrl(doc.url, url);\n\n  if (uriReference(doc.url) === uriReference(resolvedUrl)) {\n    result = extend(doc, { url: resolvedUrl });\n  } else if (doc.embedded && uriReference(resolvedUrl) in doc.embedded) {\n    const headers = { \"content-type\": doc.headers[\"content-type\"] };\n    result = construct(resolvedUrl, headers, doc.embedded[resolvedUrl]);\n  } else {\n    const response = await fetch(resolvedUrl, options);\n    const headers = {};\n    for (const [name, value] of response.headers.entries()) {\n      headers[name] = value;\n    }\n    result = construct(resolvedUrl, headers, await response.text());\n  }\n\n  return await contentTypeHandler(result).get(result, options);\n});\n\nconst step = curry(async (key, doc, options = {}) => isDocument(await doc) ? (\n  contentTypeHandler(await doc).step(key, await doc, options)\n) : (\n  (await doc)[key]\n));\n\nconst entries = async (doc, options = {}) => isDocument(await doc) ? (\n  Promise.all(Object.keys(value(await doc))\n    .map(async (key) => [key, await step(key, await doc, options)]))\n) : (\n  Object.entries(await doc)\n);\n\nconst map = curry(async (fn, doc, options = {}) => {\n  const list = (await entries(doc, options))\n    .map(([key, item]) => fn(item, key));\n\n  return Promise.all(list);\n});\n\nconst filter = curry(async (fn, doc, options = {}) => {\n  return reduce(async (acc, item) => {\n    return (await fn(item)) ? acc.concat([item]) : acc;\n  }, [], doc, options);\n});\n\nconst some = curry(async (fn, doc, options = {}) => {\n  return (await map(fn, doc, options))\n    .some((a) => a);\n});\n\nconst every = curry(async (fn, doc, options = {}) => {\n  return (await map(fn, doc, options))\n    .every((a) => a);\n});\n\nconst reduce = curry(async (fn, acc, doc, options = {}) => {\n  return (await entries(doc, options))\n    .reduce(async (acc, [_key, item]) => fn(await acc, item), acc);\n});\n\nconst pipeline = curry((fns, doc) => {\n  return fns.reduce(async (acc, fn) => fn(await acc), doc);\n});\n\nconst contentTypes = {};\n\nconst defaultHandler = {\n  get: async (doc) => doc,\n  value: source,\n  step: async (key, doc) => value(doc)[key]\n};\n\nconst addContentType = (contentType, handler) => contentTypes[contentType] = handler;\nconst getContentType = (contentType) => contentTypes[contentType];\n\nconst contentTypeHandler = (doc) => {\n  if (doc === nil) {\n    return defaultHandler;\n  }\n\n  const contentType = contentTypeParser.parse(doc.headers[\"content-type\"]).type;\n  return contentType in contentTypes ? contentTypes[contentType] : defaultHandler;\n};\n\nconst isDocument = (value) => isObject(value) && \"url\" in value;\n\nmodule.exports = {\n  construct, extend, addContentType, getContentType,\n  nil, get, source, value, entries, step, map, filter, reduce, some, every, pipeline\n};\n","const Hyperjump = require(\"../core\");\n\n\nconst get = async (doc) => {\n  const json = JSON.parse(Hyperjump.source(doc));\n  return !(\"json\" in doc) ? Hyperjump.extend(doc, { json }) : doc;\n};\nconst value = (doc) => doc.json;\nconst step = async (key, doc) => value(doc)[key];\n\nmodule.exports = { get, value, step };\n","const Hyperjump = require(\"../core\");\nconst Core = require(\"./core\");\n\n\nHyperjump.addContentType(\"application/json\", Core);\n\nmodule.exports = Hyperjump;\n","const curry = require(\"just-curry-it\");\n\n\nconst nil = \"\";\n\nconst get = (pointer, value = undefined) => {\n  if (pointer.length > 0 && pointer[0] !== \"/\") {\n    throw Error(\"Invalid JSON Pointer\");\n  }\n\n  const ptr = pointer.split(\"/\").slice(1).map(unescape);\n\n  const fn = (value) => ptr.reduce(([value, pointer], segment) => {\n    return [applySegment(value, segment, pointer), append(segment, pointer)];\n  }, [value, \"\"])[0];\n\n  return value === undefined ? fn : fn(value);\n};\n\nconst append = curry((segment, pointer) => pointer + \"/\" + escape(segment));\n\nconst escape = (segment) => segment.toString().replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\nconst unescape = (segment) => segment.toString().replace(/~0/g, \"~\").replace(/~1/g, \"/\");\n\nconst applySegment = (value, segment, pointer = \"\") => {\n  if (value === null || typeof value !== \"object\") {\n    throw Error(`Value at '${pointer}' is a scalar and can't be indexed`);\n  } else if (!(segment in value)) {\n    throw Error(`Value at '${pointer}' does not have index '${segment}'`);\n  }\n\n  return value[segment];\n};\n\nmodule.exports = { nil, get, append };\n","const JsonPointer = require(\"@hyperjump/json-pointer\");\nconst Hyperjump = require(\"../core\");\nconst { uriReference, uriFragment, isObject } = require(\"../common\");\n\n\nconst get = async (doc, options) => {\n  const jrefDoc = !(\"jref\" in doc) ? Hyperjump.extend(doc, parse(doc)) : doc;\n  const docValue = value(jrefDoc);\n  return isHref(docValue) ? await Hyperjump.get(docValue[\"$href\"], jrefDoc, options) : jrefDoc;\n};\n\nconst parse = (doc) => {\n  const embedded = {};\n  const jref = JSON.parse(Hyperjump.source(doc), (key, value) => {\n    if (isEmbedded(value)) {\n      const id = uriReference(value[\"$embedded\"]);\n      delete value[\"$embedded\"];\n      embedded[id] = JSON.stringify(value);\n      return { \"$href\": id };\n    } else {\n      return value;\n    }\n  });\n\n  return { jref, embedded };\n};\n\nconst value = (doc) => JsonPointer.get(pointer(doc), doc.jref);\n\nconst step = (key, doc, options = {}) => {\n  const ptr = JsonPointer.append(key, pointer(doc));\n  const url = \"#\" + encodeURI(ptr).replace(/#/g, \"%23\");\n  return Hyperjump.get(url, doc, options);\n};\n\nconst pointer = (doc) => decodeURIComponent(uriFragment(doc.url));\nconst isHref = (value) => isObject(value) && \"$href\" in value;\nconst isEmbedded = (value) => isObject(value) && \"$embedded\" in value;\n\nmodule.exports = { get, value, step };\n","const Hyperjump = require(\"../core\");\nconst Core = require(\"./core\");\n\n\nHyperjump.addContentType(\"application/reference+json\", Core);\n\nmodule.exports = Hyperjump;\n","const Hyperjump = require(\"./core\");\nrequire(\"./json\");\nrequire(\"./json-reference\");\n\n\nmodule.exports = Hyperjump;\n","module.exports = curry;\n\n/*\n  function add(a, b, c) {\n    return a + b + c;\n  }\n  curry(add)(1)(2)(3); // 6\n  curry(add)(1)(2)(2); // 5\n  curry(add)(2)(4, 3); // 9\n\n  function add(...args) {\n    return args.reduce((sum, n) => sum + n, 0)\n  }\n  var curryAdd4 = curry(add, 4)\n  curryAdd4(1)(2, 3)(4); // 10\n\n  function converter(ratio, input) {\n    return (input*ratio).toFixed(1);\n  }\n  const curriedConverter = curry(converter)\n  const milesToKm = curriedConverter(1.62);\n  milesToKm(35); // 56.7\n  milesToKm(10); // 16.2\n*/\n\nfunction curry(fn, arity) {\n  return function curried() {\n    if (arity == null) {\n      arity = fn.length;\n    }\n    var args = [].slice.call(arguments);\n    if (args.length >= arity) {\n      return fn.apply(this, args);\n    } else {\n      return function() {\n        return curried.apply(this, args.concat([].slice.call(arguments)));\n      };\n    }\n  };\n}\n","/*!\n * content-type\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * RegExp to match *( \";\" parameter ) in RFC 7231 sec 3.1.1.1\n *\n * parameter     = token \"=\" ( token / quoted-string )\n * token         = 1*tchar\n * tchar         = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n *               / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n *               / DIGIT / ALPHA\n *               ; any VCHAR, except delimiters\n * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE\n * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text\n * obs-text      = %x80-FF\n * quoted-pair   = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n */\nvar PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *(\"(?:[\\u000b\\u0020\\u0021\\u0023-\\u005b\\u005d-\\u007e\\u0080-\\u00ff]|\\\\[\\u000b\\u0020-\\u00ff])*\"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g\nvar TEXT_REGEXP = /^[\\u000b\\u0020-\\u007e\\u0080-\\u00ff]+$/\nvar TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/\n\n/**\n * RegExp to match quoted-pair in RFC 7230 sec 3.2.6\n *\n * quoted-pair = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n * obs-text    = %x80-FF\n */\nvar QESC_REGEXP = /\\\\([\\u000b\\u0020-\\u00ff])/g\n\n/**\n * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6\n */\nvar QUOTE_REGEXP = /([\\\\\"])/g\n\n/**\n * RegExp to match type in RFC 7231 sec 3.1.1.1\n *\n * media-type = type \"/\" subtype\n * type       = token\n * subtype    = token\n */\nvar TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/\n\n/**\n * Module exports.\n * @public\n */\n\nexports.format = format\nexports.parse = parse\n\n/**\n * Format object to media type.\n *\n * @param {object} obj\n * @return {string}\n * @public\n */\n\nfunction format (obj) {\n  if (!obj || typeof obj !== 'object') {\n    throw new TypeError('argument obj is required')\n  }\n\n  var parameters = obj.parameters\n  var type = obj.type\n\n  if (!type || !TYPE_REGEXP.test(type)) {\n    throw new TypeError('invalid type')\n  }\n\n  var string = type\n\n  // append parameters\n  if (parameters && typeof parameters === 'object') {\n    var param\n    var params = Object.keys(parameters).sort()\n\n    for (var i = 0; i < params.length; i++) {\n      param = params[i]\n\n      if (!TOKEN_REGEXP.test(param)) {\n        throw new TypeError('invalid parameter name')\n      }\n\n      string += '; ' + param + '=' + qstring(parameters[param])\n    }\n  }\n\n  return string\n}\n\n/**\n * Parse media type to object.\n *\n * @param {string|object} string\n * @return {Object}\n * @public\n */\n\nfunction parse (string) {\n  if (!string) {\n    throw new TypeError('argument string is required')\n  }\n\n  // support req/res-like objects as argument\n  var header = typeof string === 'object'\n    ? getcontenttype(string)\n    : string\n\n  if (typeof header !== 'string') {\n    throw new TypeError('argument string is required to be a string')\n  }\n\n  var index = header.indexOf(';')\n  var type = index !== -1\n    ? header.substr(0, index).trim()\n    : header.trim()\n\n  if (!TYPE_REGEXP.test(type)) {\n    throw new TypeError('invalid media type')\n  }\n\n  var obj = new ContentType(type.toLowerCase())\n\n  // parse parameters\n  if (index !== -1) {\n    var key\n    var match\n    var value\n\n    PARAM_REGEXP.lastIndex = index\n\n    while ((match = PARAM_REGEXP.exec(header))) {\n      if (match.index !== index) {\n        throw new TypeError('invalid parameter format')\n      }\n\n      index += match[0].length\n      key = match[1].toLowerCase()\n      value = match[2]\n\n      if (value[0] === '\"') {\n        // remove quotes and escapes\n        value = value\n          .substr(1, value.length - 2)\n          .replace(QESC_REGEXP, '$1')\n      }\n\n      obj.parameters[key] = value\n    }\n\n    if (index !== header.length) {\n      throw new TypeError('invalid parameter format')\n    }\n  }\n\n  return obj\n}\n\n/**\n * Get content-type from req/res objects.\n *\n * @param {object}\n * @return {Object}\n * @private\n */\n\nfunction getcontenttype (obj) {\n  var header\n\n  if (typeof obj.getHeader === 'function') {\n    // res-like\n    header = obj.getHeader('content-type')\n  } else if (typeof obj.headers === 'object') {\n    // req-like\n    header = obj.headers && obj.headers['content-type']\n  }\n\n  if (typeof header !== 'string') {\n    throw new TypeError('content-type header is missing from object')\n  }\n\n  return header\n}\n\n/**\n * Quote a string if necessary.\n *\n * @param {string} val\n * @return {string}\n * @private\n */\n\nfunction qstring (val) {\n  var str = String(val)\n\n  // no need to quote tokens\n  if (TOKEN_REGEXP.test(str)) {\n    return str\n  }\n\n  if (str.length > 0 && !TEXT_REGEXP.test(str)) {\n    throw new TypeError('invalid parameter value')\n  }\n\n  return '\"' + str.replace(QUOTE_REGEXP, '\\\\$1') + '\"'\n}\n\n/**\n * Class to represent a content type.\n * @private\n */\nfunction ContentType (type) {\n  this.parameters = Object.create(null)\n  this.type = type\n}\n","/* eslint-disable */\n'use strict';\nmodule.exports = urlResolve;\n\n/*\nThe majority of the module is built by following RFC1808\nurl: https://tools.ietf.org/html/rfc1808\n*/\n\n// adds a slash at end if not present\nfunction _addSlash (url) {\n  return url + (url[url.length-1] === '/' ? '' : '/');\n}\n\n// resolve the ..'s (directory up) and such\nfunction _pathResolve (path) {\n  let pathSplit = path.split('/');\n\n  // happens when path starts with /\n  if (pathSplit[0] === '') {\n    pathSplit = pathSplit.slice(1);\n  }\n\n  // let segmentCount = 0; // number of segments that have been passed\n  let resultArray = [];\n  pathSplit.forEach((current, index) => {\n    // skip occurances of '.'\n    if (current !== '.') {\n      if (current === '..') {\n        resultArray.pop(); // remove previous\n      } else if (current !== '') {\n        resultArray.push(current);\n      }\n    }\n  });\n  return '/' + resultArray.join('/');\n}\n\n// parses a base url string into an object containing host, path and query\nfunction _baseParse (base) {\n  const resultObject = {\n    host: '',\n    path: '',\n    query: '',\n    protocol: ''\n  };\n\n  let path = base;\n  let protocolEndIndex = base.indexOf('//');\n\n  if (protocolEndIndex === -1) {\n    throw new Error('Error, protocol is not specified');\n  }\n\n  resultObject.protocol = path.substring(0, protocolEndIndex);\n\n  protocolEndIndex += 2; // add two to pass double slash\n\n  const pathIndex = base.indexOf('/', protocolEndIndex);\n  const queryIndex = base.indexOf('?');\n  const hashIndex = base.indexOf('#');\n\n  if (hashIndex !== -1) {\n    path = path.substring(0, hashIndex); // remove hash, not needed for base\n  }\n\n  if (queryIndex !== -1) {\n    const query = path.substring(queryIndex); // remove query, save in return obj\n    resultObject.query = query;\n    path = path.substring(0, queryIndex);\n  }\n\n  if (pathIndex !== -1) {\n    const host = path.substring(0, pathIndex); // separate host & path\n    resultObject.host = host;\n    path = path.substring(pathIndex);\n    resultObject.path = path;\n  } else {\n    resultObject.host = path; // there was no path, therefore path is host\n  }\n\n  return resultObject;\n}\n\nfunction _isAbsolute(relative) {\n  // https://tools.ietf.org/html/rfc3986#section-3.1\n  const scheme = '[a-z][a-z0-9+.-]*'; // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\"  )]\n  const isAbsolutePattern = new RegExp(`^(${scheme}:)?//`, 'i');\n  return isAbsolutePattern.test(relative);\n}\n\n// parses a relative url string into an object containing the href,\n// hash, query and whether it is a net path, absolute path or relative path\nfunction _relativeParse (relative) {\n  const resultObject = {\n    href: relative, // href is always what was passed through\n    hash: '',\n    query: '',\n    netPath: false,\n    absolutePath: false,\n    relativePath: false\n  };\n  // check for protocol\n  // if protocol exists, is net path (absolute URL)\n  if (_isAbsolute(relative)) {\n    resultObject.netPath = true;\n    // return, in this case the relative is the resolved url, no need to parse.\n    return resultObject;\n  }\n\n  // if / is first, this is an absolute path,\n  // I.E. it overwrites the base URL's path\n  if (relative[0] === '/') {\n    resultObject.absolutePath = true;\n    // return resultObject\n  } else {\n    resultObject.relativePath = true;\n  }\n\n  let path = relative;\n  const queryIndex = relative.indexOf('?');\n  const hashIndex = relative.indexOf('#');\n\n  if (hashIndex !== -1) {\n    const hash = path.substring(hashIndex);\n    resultObject.hash = hash;\n    path = path.substring(0, hashIndex);\n  }\n\n  if (queryIndex !== -1) {\n    const query = path.substring(queryIndex);\n    resultObject.query = query;\n    path = path.substring(0, queryIndex);\n  }\n\n  resultObject.path = path; // whatever is left is path\n  return resultObject;\n}\n\nfunction _shouldAddSlash (url) {\n  const protocolIndex = url.indexOf('//') + 2;\n  const noPath = !(url.includes('/', protocolIndex));\n  const noQuery = !(url.includes('?', protocolIndex));\n  const noHash = !(url.includes('#', protocolIndex));\n  return (noPath && noQuery && noHash);\n}\n\nfunction _shouldAddProtocol (url) {\n  return url.startsWith('//');\n}\n\n/*\n* PRECONDITION: Base is a fully qualified URL. e.g. http://example.com/\n* optional: path, query or hash\n* returns the resolved url\n*/\nfunction urlResolve (base, relative) {\n  base = base.trim();\n  relative = relative.trim();\n\n  // about is always absolute\n  if (relative.startsWith('about:')) {\n    return relative;\n  }\n\n  // if base is empty, assume relative is a net path.\n  if (base === '') {\n    if (_shouldAddSlash(relative)) {\n      return _addSlash(relative);\n    }\n    // add / at end if not present if is only the host\n    return relative;\n  }\n  const baseObj = _baseParse(base);\n  // relative is empty, return base minus hash\n  if (relative === '') {\n    const {host, path, query} = baseObj;\n    // when path and query aren't supplied add slash\n    if ((!path) && (!query)) {\n      return _addSlash(host);\n    }\n    return host + path + query;\n  }\n\n  const relativeObj = _relativeParse(relative);\n\n  if (relativeObj.netPath) { // relative is full qualified URL\n    if (_shouldAddProtocol(relativeObj.href)) {\n      relativeObj.href = baseObj.protocol + relativeObj.href;\n    }\n\n    if (_shouldAddSlash(relativeObj.href)) {\n      return _addSlash(relativeObj.href);\n    }\n\n    return relativeObj.href;\n  } else if (relativeObj.absolutePath) { // relative is an absolute path\n    const {path, query, hash} = relativeObj;\n\n    return baseObj.host + _pathResolve(path) + query + hash;\n  } else if (relativeObj.relativePath) { // relative is a relative path\n    const {path, query, hash} = relativeObj;\n\n    let basePath = baseObj.path;\n    let resultString = baseObj.host;\n\n    let resolvePath;\n\n    if (path.length === 0) {\n      resolvePath = basePath;\n    } else {\n      // remove last segment if no slash at end\n      basePath = basePath.substring(0, basePath.lastIndexOf('/'));\n      resolvePath = _pathResolve(basePath + '/' + path);\n    }\n\n    // if result is just the base host, add /\n    if ((resolvePath === '') && (!query) && (!hash)) {\n      resultString += '/';\n    } else {\n      resultString += resolvePath + query + hash;\n    }\n\n    return resultString;\n  }\n}\n","module.exports = fetch;\n","const uriReference = (url) => url.split(\"#\", 1)[0];\nconst uriFragment = (url) => url.split(\"#\", 2)[1] || \"\";\nconst isObject = (value) => typeof value === \"object\" && !Array.isArray(value) && value !== null;\n\nmodule.exports = { uriReference, uriFragment, isObject };\n","const curry = require(\"just-curry-it\");\nconst contentTypeParser = require(\"content-type\");\nconst resolveUrl = require(\"./url-resolve-browser\");\nconst fetch = require(\"./fetch\");\nconst { uriReference, isObject } = require(\"./common\");\n\n\nconst construct = (url, headers, body) => Object.freeze({ url, headers, body });\nconst extend = (doc, extras) => Object.freeze({ ...doc, ...extras });\n\nconst nil = construct(\"\", {}, undefined);\nconst source = (doc) => doc.body;\nconst value = (doc) => isDocument(doc) ? contentTypeHandler(doc).value(doc) : doc;\n\nconst get = curry(async (url, contextDoc, options = {}) => {\n  let result;\n  const doc = await contextDoc;\n  const resolvedUrl = resolveUrl(doc.url, url);\n\n  if (uriReference(doc.url) === uriReference(resolvedUrl)) {\n    result = extend(doc, { url: resolvedUrl });\n  } else if (doc.embedded && uriReference(resolvedUrl) in doc.embedded) {\n    const headers = { \"content-type\": doc.headers[\"content-type\"] };\n    result = construct(resolvedUrl, headers, doc.embedded[resolvedUrl]);\n  } else {\n    const response = await fetch(resolvedUrl, options);\n    const headers = {};\n    for (const [name, value] of response.headers.entries()) {\n      headers[name] = value;\n    }\n    result = construct(resolvedUrl, headers, await response.text());\n  }\n\n  return await contentTypeHandler(result).get(result, options);\n});\n\nconst step = curry(async (key, doc, options = {}) => isDocument(await doc) ? (\n  contentTypeHandler(await doc).step(key, await doc, options)\n) : (\n  (await doc)[key]\n));\n\nconst entries = async (doc, options = {}) => isDocument(await doc) ? (\n  Promise.all(Object.keys(value(await doc))\n    .map(async (key) => [key, await step(key, await doc, options)]))\n) : (\n  Object.entries(await doc)\n);\n\nconst map = curry(async (fn, doc, options = {}) => {\n  const list = (await entries(doc, options))\n    .map(([key, item]) => fn(item, key));\n\n  return Promise.all(list);\n});\n\nconst filter = curry(async (fn, doc, options = {}) => {\n  return reduce(async (acc, item) => {\n    return (await fn(item)) ? acc.concat([item]) : acc;\n  }, [], doc, options);\n});\n\nconst some = curry(async (fn, doc, options = {}) => {\n  return (await map(fn, doc, options))\n    .some((a) => a);\n});\n\nconst every = curry(async (fn, doc, options = {}) => {\n  return (await map(fn, doc, options))\n    .every((a) => a);\n});\n\nconst reduce = curry(async (fn, acc, doc, options = {}) => {\n  return (await entries(doc, options))\n    .reduce(async (acc, [_key, item]) => fn(await acc, item), acc);\n});\n\nconst pipeline = curry((fns, doc) => {\n  return fns.reduce(async (acc, fn) => fn(await acc), doc);\n});\n\nconst contentTypes = {};\n\nconst defaultHandler = {\n  get: async (doc) => doc,\n  value: source,\n  step: async (key, doc) => value(doc)[key]\n};\n\nconst addContentType = (contentType, handler) => contentTypes[contentType] = handler;\nconst getContentType = (contentType) => contentTypes[contentType];\n\nconst contentTypeHandler = (doc) => {\n  if (doc === nil) {\n    return defaultHandler;\n  }\n\n  const contentType = contentTypeParser.parse(doc.headers[\"content-type\"]).type;\n  return contentType in contentTypes ? contentTypes[contentType] : defaultHandler;\n};\n\nconst isDocument = (value) => isObject(value) && \"url\" in value;\n\nmodule.exports = {\n  construct, extend, addContentType, getContentType,\n  nil, get, source, value, entries, step, map, filter, reduce, some, every, pipeline\n};\n","const Hyperjump = require(\"../core\");\n\n\nconst get = async (doc) => {\n  const json = JSON.parse(Hyperjump.source(doc));\n  return !(\"json\" in doc) ? Hyperjump.extend(doc, { json }) : doc;\n};\nconst value = (doc) => doc.json;\nconst step = async (key, doc) => value(doc)[key];\n\nmodule.exports = { get, value, step };\n","const Hyperjump = require(\"../core\");\nconst Core = require(\"./core\");\n\n\nHyperjump.addContentType(\"application/json\", Core);\n\nmodule.exports = Hyperjump;\n","const curry = require(\"just-curry-it\");\n\n\nconst nil = \"\";\n\nconst get = (pointer, value = undefined) => {\n  if (pointer.length > 0 && pointer[0] !== \"/\") {\n    throw Error(\"Invalid JSON Pointer\");\n  }\n\n  const ptr = pointer.split(\"/\").slice(1).map(unescape);\n\n  const fn = (value) => ptr.reduce(([value, pointer], segment) => {\n    return [applySegment(value, segment, pointer), append(segment, pointer)];\n  }, [value, \"\"])[0];\n\n  return value === undefined ? fn : fn(value);\n};\n\nconst append = curry((segment, pointer) => pointer + \"/\" + escape(segment));\n\nconst escape = (segment) => segment.toString().replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\nconst unescape = (segment) => segment.toString().replace(/~0/g, \"~\").replace(/~1/g, \"/\");\n\nconst applySegment = (value, segment, pointer = \"\") => {\n  if (value === null || typeof value !== \"object\") {\n    throw Error(`Value at '${pointer}' is a scalar and can't be indexed`);\n  } else if (!(segment in value)) {\n    throw Error(`Value at '${pointer}' does not have index '${segment}'`);\n  }\n\n  return value[segment];\n};\n\nmodule.exports = { nil, get, append };\n","const JsonPointer = require(\"@hyperjump/json-pointer\");\nconst Hyperjump = require(\"../core\");\nconst { uriReference, uriFragment, isObject } = require(\"../common\");\n\n\nconst get = async (doc, options) => {\n  const jrefDoc = !(\"jref\" in doc) ? Hyperjump.extend(doc, parse(doc)) : doc;\n  const docValue = value(jrefDoc);\n  return isHref(docValue) ? await Hyperjump.get(docValue[\"$href\"], jrefDoc, options) : jrefDoc;\n};\n\nconst parse = (doc) => {\n  const embedded = {};\n  const jref = JSON.parse(Hyperjump.source(doc), (key, value) => {\n    if (isEmbedded(value)) {\n      const id = uriReference(value[\"$embedded\"]);\n      delete value[\"$embedded\"];\n      embedded[id] = JSON.stringify(value);\n      return { \"$href\": id };\n    } else {\n      return value;\n    }\n  });\n\n  return { jref, embedded };\n};\n\nconst value = (doc) => JsonPointer.get(pointer(doc), doc.jref);\n\nconst step = (key, doc, options = {}) => {\n  const ptr = JsonPointer.append(key, pointer(doc));\n  const url = \"#\" + encodeURI(ptr).replace(/#/g, \"%23\");\n  return Hyperjump.get(url, doc, options);\n};\n\nconst pointer = (doc) => decodeURIComponent(uriFragment(doc.url));\nconst isHref = (value) => isObject(value) && \"$href\" in value;\nconst isEmbedded = (value) => isObject(value) && \"$embedded\" in value;\n\nmodule.exports = { get, value, step };\n","const Hyperjump = require(\"../core\");\nconst Core = require(\"./core\");\n\n\nHyperjump.addContentType(\"application/reference+json\", Core);\n\nmodule.exports = Hyperjump;\n","const Hyperjump = require(\"./core\");\nrequire(\"./json\");\nrequire(\"./json-reference\");\n\n\nmodule.exports = Hyperjump;\n","(function(global){\n  \"use strict\";\n  // In this NodeJS version, Buffers are supported and used as fallback in versions that do not support Typed Arrays\n  var log = Math.log;\n  var LN2 = Math.LN2;\n  var clz32 = Math.clz32 || function(x) {return 31 - log(x >>> 0) / LN2 | 0};\n  var fromCharCode = String.fromCharCode;\n  var Object_prototype_toString = ({}).toString;\n  var NativeBuffer = global[\"Buffer\"];\n  if (!NativeBuffer && global[\"require\"]) try{NativeBuffer=global[\"require\"](\"Buffer\")}catch(e){}\n  var NativeBufferString = NativeBuffer && Object_prototype_toString.call(NativeBuffer.prototype);\n  var NativeUint8Array = global.Uint8Array;\n  var usingTypedArrays = NativeUint8Array && (!NativeBuffer || NativeUint8Array.prototype.isPrototypeOf(NativeBuffer));\n  var ArrayBufferString = usingTypedArrays && Object_prototype_toString.call(global.ArrayBuffer.prototype);\n  if (usingTypedArrays || NativeBuffer) {\n    function decoderReplacer(encoded){\n      var codePoint = encoded.charCodeAt(0) << 24;\n      var leadingOnes = clz32(~codePoint)|0;\n      var endPos = 0, stringLen = encoded.length|0;\n      var result = \"\";\n      if (leadingOnes < 5 && stringLen >= leadingOnes) {\n        codePoint = (codePoint<<leadingOnes)>>>(24+leadingOnes);\n        for (endPos = 1; endPos < leadingOnes; endPos=endPos+1|0)\n          codePoint = (codePoint<<6) | (encoded.charCodeAt(endPos)&0x3f/*0b00111111*/);\n        if (codePoint <= 0xFFFF) { // BMP code point\n          result += fromCharCode(codePoint);\n        } else if (codePoint <= 0x10FFFF) {\n          // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n          codePoint = codePoint - 0x10000|0;\n          result += fromCharCode(\n            (codePoint >> 10) + 0xD800|0,  // highSurrogate\n            (codePoint & 0x3ff) + 0xDC00|0 // lowSurrogate\n          );\n        } else endPos = 0; // to fill it in with INVALIDs\n      }\n      for (; endPos < stringLen; endPos=endPos+1|0) result += \"\\ufffd\"; // replacement character\n      return result;\n    }\n    function TextDecoder(){};\n    function decode(inputArrayOrBuffer){\n      var buffer = (inputArrayOrBuffer && inputArrayOrBuffer.buffer) || inputArrayOrBuffer;\n      var asString = Object_prototype_toString.call(buffer);\n      if (asString !== ArrayBufferString && asString !== NativeBufferString)\n        throw Error(\"Failed to execute 'decode' on 'TextDecoder': The provided value is not of type '(ArrayBuffer or ArrayBufferView)'\");\n      var inputAs8 = usingTypedArrays ? new NativeUint8Array(buffer) : buffer;\n      var resultingString = \"\";\n      for (var index=0,len=inputAs8.length|0; index<len; index=index+32768|0)\n        resultingString += fromCharCode.apply(0, inputAs8[usingTypedArrays ? \"subarray\" : \"slice\"](index,index+32768|0));\n\n      return resultingString.replace(/[\\xc0-\\xff][\\x80-\\xbf]*/g, decoderReplacer);\n    }\n    TextDecoder.prototype.decode = decode;\n    //////////////////////////////////////////////////////////////////////////////////////\n    function encoderReplacer(nonAsciiChars){\n      // make the UTF string into a binary UTF-8 encoded string\n      var point = nonAsciiChars.charCodeAt(0)|0;\n      if (point >= 0xD800 && point <= 0xDBFF) {\n        var nextcode = nonAsciiChars.charCodeAt(1)|0;\n        if (nextcode !== nextcode) // NaN because string is 1 code point long\n          return fromCharCode(0xef/*11101111*/, 0xbf/*10111111*/, 0xbd/*10111101*/);\n        // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        if (nextcode >= 0xDC00 && nextcode <= 0xDFFF) {\n          point = ((point - 0xD800)<<10) + nextcode - 0xDC00 + 0x10000|0;\n          if (point > 0xffff)\n            return fromCharCode(\n              (0x1e/*0b11110*/<<3) | (point>>>18),\n              (0x2/*0b10*/<<6) | ((point>>>12)&0x3f/*0b00111111*/),\n              (0x2/*0b10*/<<6) | ((point>>>6)&0x3f/*0b00111111*/),\n              (0x2/*0b10*/<<6) | (point&0x3f/*0b00111111*/)\n            );\n        } else return fromCharCode(0xef, 0xbf, 0xbd);\n      }\n      if (point <= 0x007f) return nonAsciiChars;\n      else if (point <= 0x07ff) {\n        return fromCharCode((0x6<<5)|(point>>>6), (0x2<<6)|(point&0x3f));\n      } else return fromCharCode(\n        (0xe/*0b1110*/<<4) | (point>>>12),\n        (0x2/*0b10*/<<6) | ((point>>>6)&0x3f/*0b00111111*/),\n        (0x2/*0b10*/<<6) | (point&0x3f/*0b00111111*/)\n      );\n    }\n    function TextEncoder(){};\n    function encode(inputString){\n      // 0xc0 => 0b11000000; 0xff => 0b11111111; 0xc0-0xff => 0b11xxxxxx\n      // 0x80 => 0b10000000; 0xbf => 0b10111111; 0x80-0xbf => 0b10xxxxxx\n      var encodedString = inputString === void 0 ?  \"\" : (\"\" + inputString).replace(/[\\x80-\\uD7ff\\uDC00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]?/g, encoderReplacer);\n      var len=encodedString.length|0, result = new (usingTypedArrays ? NativeUint8Array : NativeBuffer)(len);\n      for (var i=0; i<len; i=i+1|0)\n        result[i] = encodedString.charCodeAt(i)|0;\n      return result;\n    };\n    TextEncoder.prototype.encode = encode;\n    function factory(obj) {\n        if (!obj[\"TextDecoder\"]) obj[\"TextDecoder\"] = TextDecoder;\n        if (!obj[\"TextEncoder\"]) obj[\"TextEncoder\"] = TextEncoder;\n        if (obj !== global) obj[\"decode\"] = decode, obj[\"encode\"] = encode;\n        return obj;\n    };\n\n    typeof define == typeof factory && define[\"amd\"] ? define(function(){\n        return factory({});\n    }) : factory(typeof exports == 'object' ? exports : global);\n  }\n})(typeof global == \"\" + void 0 ? typeof self == \"\" + void 0 ? this : self : global);\n","const { encode } = require(\"fastestsmallesttextencoderdecoder\");\n\n\nconst isObject = (value) => typeof value === \"object\" && !Array.isArray(value) && value !== null;\n\nconst isType = {\n  \"null\": (value) => value === null,\n  \"boolean\": (value) => typeof value === \"boolean\",\n  \"object\": isObject,\n  \"array\": (value) => Array.isArray(value),\n  \"number\": (value) => typeof value === \"number\",\n  \"string\": (value) => typeof value === \"string\"\n};\n\nconst numberEqual = (a, b) => {\n  return Math.abs(a - b) < Number.EPSILON;\n};\n\nconst jsonStringLength = (string) => encode(string).length;\n\nmodule.exports = { isObject, isType, numberEqual, jsonStringLength };\n","const JsonPointer = require(\"@hyperjump/json-pointer\");\nconst Hyperjump = require(\"@hyperjump/browser\");\nconst { isType, isObject } = require(\"./common\");\n\n\nconst validate = async (d) => {\n  const doc = await d;\n  const meta = await metaCompile(doc);\n  const result = await metaInterpret(meta, doc, new Set());\n\n  if (!isValid(result)) {\n    throw result;\n  }\n\n  const ast = await compile(doc, {});\n  return interpret(ast, doc.url);\n};\n\nconst compile = async (doc, ast) => {\n  if (!(doc.url in ast)) {\n    ast[doc.url] = false;\n\n    const meta = await getMeta(doc);\n\n    ast[doc.url] = await Hyperjump.pipeline([\n      Hyperjump.entries,\n      Hyperjump.filter(([keyword]) => keyword !== \"$meta\"),\n      Hyperjump.map(async ([keyword, keywordDoc]) => {\n        if (!(keyword in meta)) {\n          throw Error(`Encountered undeclared keyword '${keyword}' at '${keywordDoc.url}'`);\n        }\n\n        const keywordUrl = meta[keyword];\n        const node = await keywords[keywordUrl].compile(keywordDoc, ast);\n\n        return [keywordUrl, keywordDoc.url, node];\n      })\n    ], doc);\n  }\n\n  return ast;\n};\n\nconst metaAst = {};\nconst metaCompile = async (doc) => {\n  const meta = await getMeta(doc);\n\n  await Promise.all(Object.entries(meta)\n    .filter(([keyword, keywordUrl]) => keyword[0] !== \"$\" && !(keywordUrl in metaAst))\n    .map(async ([keyword, _]) => {\n      const keywordUrl = meta[keyword];\n      const metaDoc = await Hyperjump.get(keywordUrl, Hyperjump.nil);\n      return await compile(metaDoc, metaAst);\n    }));\n\n  return meta;\n};\n\nconst isDocument = (value) => isObject(value) && \"url\" in value;\nconst interpret = (ast, url) => async (d, memo = new Set) => {\n  const doc = await d;\n  // Cycle protection\n  if (isDocument(doc)) {\n    const docKey = `${url}--${doc.url}`;\n    if (memo.has(docKey)) {\n      return [];\n    } else {\n      memo.add(docKey);\n    }\n  }\n\n  return Hyperjump.map(async ([keywordUrl, ptr, keywordValue]) => {\n    const keyword = keywords[keywordUrl];\n    const isValid = (keyword.type !== undefined && !isType[keyword.type](Hyperjump.value(doc))) || await keyword.interpret(keywordValue, doc, ast, memo);\n\n    return [ptr, isValid];\n  }, ast[url]);\n};\n\nconst metaInterpret = (meta, doc, memo) => {\n  return Hyperjump.pipeline([\n    Hyperjump.entries,\n    Hyperjump.filter(([keyword]) => keyword in meta),\n    Hyperjump.map(async ([keyword, keywordValue]) => {\n      const keywordUrl = meta[keyword];\n      const result = await interpret(metaAst, keywordUrl)(keywordValue, memo);\n      return [JsonPointer.append(keyword, JsonPointer.nil), isValid(result)];\n    })\n  ], doc);\n};\n\nconst getMeta = async (doc) => {\n  try {\n    const $meta = await Hyperjump.get(\"#/$meta\", doc);\n    return Hyperjump.value($meta);\n  } catch (e) {\n    return {};\n  }\n};\n\nconst isValid = (result) => result.every(([_pointer, isValid]) => isValid);\n\nconst keywords = {};\n\nconst addKeyword = (url, keywordDefinition) => keywords[url] = keywordDefinition;\n\nmodule.exports = { compile, metaCompile, interpret, metaInterpret, addKeyword, validate, isValid };\n","'use strict';\n\nvar keyList = Object.keys;\nvar native_stringify = JSON.stringify;\n\nfunction stringify(val, allowUndefined) {\n    var i, max, str, keys, key, propVal, tipeof;\n\n    tipeof = typeof val;\n\n    if (tipeof === 'string') return native_stringify(val);\n    if (val === true) return 'true';\n    if (val === false) return 'false';\n    if (val === null) return 'null';\n\n    if (val instanceof Array) {\n        str = '[';\n        max = val.length - 1;\n        for(i = 0; i < max; i++)\n            str += stringify(val[i], false) + ',';\n        if (max > -1) {\n            str += stringify(val[i], false);\n        }\n\n        return str + ']';\n    }\n\n    if (val instanceof Object) {\n        if (typeof val.toJSON === 'function')\n            return stringify(val.toJSON(), allowUndefined);\n\n        // only object is left\n        keys = keyList(val).sort();\n        max = keys.length;\n        str = '';\n        i = 0;\n        while (i < max) {\n            key = keys[i];\n            propVal = stringify(val[key], true);\n            if (propVal !== undefined) {\n                if (i && str !== '') { //if the string is empty, don't add comma to avoid the json to become invalid.\n                    str += ',';\n                }\n                str += native_stringify(key) + ':' + propVal;\n            }\n            i++;\n        }\n        return '{' + str + '}';\n    }\n\n    switch (tipeof) {\n    case 'function':\n    case 'undefined':\n        return allowUndefined ? undefined : null;\n    default:\n        return isFinite(val) ? val : null;\n    }\n}\n\nmodule.exports = function(obj) { return '' + stringify(obj, false); };\n","const Hyperjump = require(\"@hyperjump/browser\");\nconst jsonStringify = require(\"fastest-stable-stringify\");\n\n\nconst compile = async (doc) => jsonStringify(Hyperjump.value(doc));\nconst interpret = (constValue, doc) => jsonStringify(Hyperjump.value(doc)) === constValue;\n\nmodule.exports = { compile, interpret };\n","const Hyperjump = require(\"@hyperjump/browser\");\nconst { isType } = require(\"../../common\");\n\n\nconst compile = async (doc) => Hyperjump.value(doc);\nconst interpret = (type, doc) => isType[type](Hyperjump.value(doc));\n\nmodule.exports = { compile, interpret };\n","const Hyperjump = require(\"@hyperjump/browser\");\nconst { numberEqual } = require(\"../../common\");\n\n\nconst type = \"number\";\n\nconst compile = async (doc) => Hyperjump.value(doc);\n\nconst interpret = (multipleOf, doc) => {\n  const remainder = Hyperjump.value(doc) % multipleOf;\n  return numberEqual(0, remainder) || numberEqual(multipleOf, remainder);\n};\n\nmodule.exports = { type, compile, interpret };\n","const Hyperjump = require(\"@hyperjump/browser\");\n\n\nconst type = \"number\";\nconst compile = async (doc) => Hyperjump.value(doc);\nconst interpret =  (maximum, doc) => Hyperjump.value(doc) <= maximum;\n\nmodule.exports = { type, compile, interpret };\n","const Hyperjump = require(\"@hyperjump/browser\");\n\n\nconst type = \"number\";\nconst compile = async (doc) => Hyperjump.value(doc);\nconst interpret =  (exclusiveMaximum, doc) => Hyperjump.value(doc) < exclusiveMaximum;\n\nmodule.exports = { type, compile, interpret };\n","const Hyperjump = require(\"@hyperjump/browser\");\n\n\nconst type = \"number\";\nconst compile = async (doc) => Hyperjump.value(doc);\nconst interpret =  (minimum, doc) => Hyperjump.value(doc) >= minimum;\n\nmodule.exports = { type, compile, interpret };\n","const Hyperjump = require(\"@hyperjump/browser\");\n\n\nconst type = \"number\";\nconst compile = async (doc) => Hyperjump.value(doc);\nconst interpret = (exclusiveMinimum, doc) => Hyperjump.value(doc) > exclusiveMinimum;\n\nmodule.exports = { type, compile, interpret };\n","const Hyperjump = require(\"@hyperjump/browser\");\nconst { jsonStringLength } = require(\"../../common\");\n\n\nconst type = \"string\";\nconst compile = async (doc) => Hyperjump.value(doc);\nconst interpret = (maxLength, doc) => jsonStringLength(Hyperjump.value(doc)) <= maxLength;\n\nmodule.exports = { type, compile, interpret };\n","const Hyperjump = require(\"@hyperjump/browser\");\nconst { jsonStringLength } = require(\"../../common\");\n\n\nconst type = \"string\";\nconst compile = async (doc) => Hyperjump.value(doc);\nconst interpret = (minLength, doc) => jsonStringLength(Hyperjump.value(doc)) >= minLength;\n\nmodule.exports = { type, compile, interpret };\n","const Hyperjump = require(\"@hyperjump/browser\");\n\n\nconst type = \"string\";\nconst compile = async (doc) => new RegExp(Hyperjump.value(doc));\nconst interpret = (pattern, doc) => pattern.test(Hyperjump.value(doc));\n\nmodule.exports = { type, compile, interpret };\n","const Hyperjump = require(\"@hyperjump/browser\");\nconst HVal = require(\"../../core\");\n\n\nconst type = \"array\";\n\nconst compile = async (doc, ast) => {\n  await HVal.compile(doc, ast);\n  return doc.url;\n};\n\nconst interpret = (items, doc, ast, memo) => {\n  return Hyperjump.every(async (item) => {\n    const result = await HVal.interpret(ast, items)(item, memo);\n    return HVal.isValid(result);\n  }, doc);\n};\n\nmodule.exports = { type, compile, interpret };\n","const Hyperjump = require(\"@hyperjump/browser\");\nconst HVal = require(\"../../core\");\n\n\nconst type = \"array\";\n\nconst compile = async (doc, ast) => await Hyperjump.map(async (itemDoc) => {\n  await HVal.compile(itemDoc, ast);\n  return itemDoc.url;\n}, doc);\n\nconst interpret = (tupleItems, doc, ast, memo) => {\n  return Hyperjump.every(async (item, ndx) => {\n    if (!(ndx in tupleItems)) {\n      return true;\n    }\n\n    const result = await HVal.interpret(ast, tupleItems[ndx])(item, memo);\n    return HVal.isValid(result);\n  }, doc);\n};\n\nmodule.exports = { type, compile, interpret };\n","const Hyperjump = require(\"@hyperjump/browser\");\n\n\nconst type = \"array\";\nconst compile = async (doc) => Hyperjump.value(doc);\nconst interpret = (maxItems, doc) => Hyperjump.value(doc).length <= maxItems;\n\nmodule.exports = { type, compile, interpret };\n","const Hyperjump = require(\"@hyperjump/browser\");\n\n\nconst type = \"array\";\nconst compile = async (doc) => Hyperjump.value(doc);\nconst interpret = (minItems, doc) => Hyperjump.value(doc).length >= minItems;\n\nmodule.exports = { type, compile, interpret };\n","const Hyperjump = require(\"@hyperjump/browser\");\nconst jsonStringify = require(\"fastest-stable-stringify\");\n\n\nconst type = \"array\";\n\nconst compile = async (doc) => Hyperjump.value(doc);\n\nconst interpret = async (uniqueItems, doc) => {\n  if (uniqueItems === false) {\n    return true;\n  }\n\n  const normalizedItems = await Hyperjump.map(jsonStringify, doc);\n  return (new Set(normalizedItems)).size === normalizedItems.length;\n};\n\nmodule.exports = { type, compile, interpret };\n","const Hyperjump = require(\"@hyperjump/browser\");\nconst HVal = require(\"../../core\");\n\n\nconst type = \"object\";\n\nconst compile = async (doc, ast) => await Hyperjump.pipeline([\n  Hyperjump.entries,\n  Hyperjump.reduce(async (acc, [propertyName, propertyDoc]) => {\n    await HVal.compile(propertyDoc, ast);\n    acc[propertyName] = propertyDoc.url;\n    return acc;\n  }, {})\n], doc);\n\nconst interpret = (properties, doc, ast, memo) => {\n  return Hyperjump.pipeline([\n    Hyperjump.entries,\n    Hyperjump.filter(([propertyName]) => propertyName in properties),\n    Hyperjump.every(async ([propertyName, propertyValue]) => {\n      const result = await HVal.interpret(ast, properties[propertyName])(propertyValue, memo);\n      return HVal.isValid(result);\n    })\n  ], doc);\n};\n\nmodule.exports = { type, compile, interpret };\n","const Hyperjump = require(\"@hyperjump/browser\");\nconst HVal = require(\"../../core\");\n\n\nconst type = \"object\";\n\nconst compile = async (doc, ast) => Hyperjump.pipeline([\n  Hyperjump.entries,\n  Hyperjump.map(async ([propertyPattern, propertyDoc]) => {\n    await HVal.compile(propertyDoc, ast);\n    return [new RegExp(propertyPattern), propertyDoc.url];\n  })\n], doc);\n\nconst interpret = (patternProperties, doc, ast, memo) => {\n  return Hyperjump.every(([pattern, property]) => {\n    return Hyperjump.pipeline([\n      Hyperjump.entries,\n      Hyperjump.filter(([propertyName]) => pattern.test(propertyName)),\n      Hyperjump.every(async ([, propertyValue]) => {\n        const result = await HVal.interpret(ast, property)(propertyValue, memo);\n        return HVal.isValid(result);\n      })\n    ], doc);\n  }, patternProperties);\n};\n\nmodule.exports = { type, compile, interpret };\n","const Hyperjump = require(\"@hyperjump/browser\");\nconst HVal = require(\"../../core\");\n\n\nconst type = \"object\";\n\nconst compile = async (doc, ast) => {\n  await HVal.compile(doc, ast);\n  return doc.url;\n};\n\nconst interpret = (propertyNames, doc, ast, memo) => {\n  return Hyperjump.pipeline([\n    Hyperjump.entries,\n    Hyperjump.every(async ([name]) => {\n      const result = await HVal.interpret(ast, propertyNames)(name, memo);\n      return HVal.isValid(result);\n    })\n  ], doc);\n};\n\nmodule.exports = { type, compile, interpret };\n","const Hyperjump = require(\"@hyperjump/browser\");\n\n\nconst type = \"object\";\nconst compile = async (doc) => Hyperjump.value(doc);\nconst interpret = (maxProperties, doc) => Object.keys(Hyperjump.value(doc)).length <= maxProperties;\n\nmodule.exports = { type, compile, interpret };\n","const Hyperjump = require(\"@hyperjump/browser\");\n\n\nconst type = \"object\";\nconst compile = async (doc) => Hyperjump.value(doc);\nconst interpret = (minProperties, doc) => Object.keys(Hyperjump.value(doc)).length >= minProperties;\n\nmodule.exports = { type, compile, interpret };\n","const Hyperjump = require(\"@hyperjump/browser\");\n\n\nconst type = \"object\";\nconst compile = async (doc) => Hyperjump.value(doc);\nconst interpret = (required, doc) => required.every((propertyName) => propertyName in Hyperjump.value(doc));\n\nmodule.exports = { type, compile, interpret };\n","const Hyperjump = require(\"@hyperjump/browser\");\nconst HVal = require(\"../../core\");\n\n\nconst compile = async (doc, ast) => await Hyperjump.map(async (subDoc) => {\n  await HVal.compile(subDoc, ast);\n  return subDoc.url;\n}, doc);\n\nconst interpret = (allOf, doc, ast, memo) => {\n  return Hyperjump.every(async (subDoc) => {\n    const result = await HVal.interpret(ast, subDoc)(doc, memo);\n    return HVal.isValid(result);\n  }, allOf);\n};\n\nmodule.exports = { compile, interpret };\n","const Hyperjump = require(\"@hyperjump/browser\");\nconst HVal = require(\"../../core\");\n\n\nconst compile = async (doc, ast) => await Hyperjump.map(async (subDoc) => {\n  await HVal.compile(subDoc, ast);\n  return subDoc.url;\n}, doc);\n\nconst interpret = (anyOf, doc, ast, memo) => {\n  return Hyperjump.some(async (url) => {\n    const result = await HVal.interpret(ast, url)(doc, memo);\n    return HVal.isValid(result);\n  }, anyOf);\n};\n\nmodule.exports = { compile, interpret };\n","const Hyperjump = require(\"@hyperjump/browser\");\nconst HVal = require(\"../../core\");\n\n\nconst compile = async (doc, ast) => await Hyperjump.map(async (subDoc) => {\n  await HVal.compile(subDoc, ast);\n  return subDoc.url;\n}, doc);\n\nconst interpret = (oneOf, doc, ast, memo) => {\n  return Hyperjump.reduce(async (acc, subDoc) => {\n    const result = await HVal.interpret(ast, subDoc)(doc, memo);\n    const isValid = HVal.isValid(result);\n    return acc ? !isValid : isValid;\n  }, false, oneOf);\n};\n\nmodule.exports = { compile, interpret };\n","const HVal = require(\"../../core\");\n\n\nconst compile = async (doc, ast) => {\n  await HVal.compile(doc, ast);\n  return doc.url;\n};\n\nconst interpret = async (not, doc, ast, memo) => {\n  const result = await HVal.interpret(ast, not)(doc, memo);\n  return !HVal.isValid(result);\n};\n\nmodule.exports = { compile, interpret };\n","const compile = async () => undefined;\nconst interpret = () => true;\n\nmodule.exports = { compile, interpret };\n","const Hyperjump = require(\"@hyperjump/browser\");\nconst HVal = require(\"../../core\");\n\n\nconst type = \"object\";\n\nconst compile = async (doc) => {\n  const meta = await HVal.metaCompile(doc);\n  return [Hyperjump.value(doc), meta];\n};\n\nconst interpret = async ([validation, meta], doc, ast, memo) => {\n  if (!validation) {\n    return true;\n  }\n\n  const result = await HVal.metaInterpret(meta, doc, memo);\n  return HVal.isValid(result);\n};\n\nmodule.exports = { type, compile, interpret };\n","const Hyperjump = require(\"@hyperjump/browser\");\nconst Core = require(\"./core\");\n\n\nconst JRef = Hyperjump.getContentType(\"application/reference+json\");\nHyperjump.addContentType(\"application/validation+json\", JRef);\n\nmodule.exports = Object.assign({}, Hyperjump, Core);\n\nconst keywordDomain = \"http://validation.hyperjump.io/common\";\nCore.addKeyword(`${keywordDomain}/const`, require(\"./keywords/common/const\"));\nCore.addKeyword(`${keywordDomain}/type`, require(\"./keywords/common/type\"));\nCore.addKeyword(`${keywordDomain}/multipleOf`, require(\"./keywords/common/multipleOf\"));\nCore.addKeyword(`${keywordDomain}/maximum`, require(\"./keywords/common/maximum\"));\nCore.addKeyword(`${keywordDomain}/exclusiveMaximum`, require(\"./keywords/common/exclusiveMaximum\"));\nCore.addKeyword(`${keywordDomain}/minimum`, require(\"./keywords/common/minimum\"));\nCore.addKeyword(`${keywordDomain}/exclusiveMinimum`, require(\"./keywords/common/exclusiveMinimum\"));\nCore.addKeyword(`${keywordDomain}/maxLength`, require(\"./keywords/common/maxLength\"));\nCore.addKeyword(`${keywordDomain}/minLength`, require(\"./keywords/common/minLength\"));\nCore.addKeyword(`${keywordDomain}/pattern`, require(\"./keywords/common/pattern\"));\nCore.addKeyword(`${keywordDomain}/items`, require(\"./keywords/common/items\"));\nCore.addKeyword(`${keywordDomain}/tupleItems`, require(\"./keywords/common/tupleItems\"));\nCore.addKeyword(`${keywordDomain}/maxItems`, require(\"./keywords/common/maxItems\"));\nCore.addKeyword(`${keywordDomain}/minItems`, require(\"./keywords/common/minItems\"));\nCore.addKeyword(`${keywordDomain}/uniqueItems`, require(\"./keywords/common/uniqueItems\"));\nCore.addKeyword(`${keywordDomain}/properties`, require(\"./keywords/common/properties\"));\nCore.addKeyword(`${keywordDomain}/patternProperties`, require(\"./keywords/common/patternProperties\"));\nCore.addKeyword(`${keywordDomain}/propertyNames`, require(\"./keywords/common/propertyNames\"));\nCore.addKeyword(`${keywordDomain}/maxProperties`, require(\"./keywords/common/maxProperties\"));\nCore.addKeyword(`${keywordDomain}/minProperties`, require(\"./keywords/common/minProperties\"));\nCore.addKeyword(`${keywordDomain}/required`, require(\"./keywords/common/required\"));\nCore.addKeyword(`${keywordDomain}/allOf`, require(\"./keywords/common/allOf\"));\nCore.addKeyword(`${keywordDomain}/anyOf`, require(\"./keywords/common/anyOf\"));\nCore.addKeyword(`${keywordDomain}/oneOf`, require(\"./keywords/common/oneOf\"));\nCore.addKeyword(`${keywordDomain}/not`, require(\"./keywords/common/not\"));\nCore.addKeyword(`${keywordDomain}/definitions`, require(\"./keywords/common/definitions\"));\nCore.addKeyword(`${keywordDomain}/validation`, require(\"./keywords/common/validation\"));\n","<script>\n  import Hyperjump from \"@hyperjump/browser\";\n  import Validation from \"@hyperjump/validation\";\n\n\n  let validation = \"\";\n  const validationUrl = \"https://mock.hyperjump.io/validation\";\n\n  $: validate = (async function () {\n    if (validation !== \"\") {\n      fetchStub.set(validationUrl, validation, \"application/reference+json\");\n\n      const doc = Hyperjump.get(validationUrl, Hyperjump.nil);\n      return Validation.validate(doc);\n    }\n  }());\n\n  let subject = \"\";\n  const subjectUrl = \"https://mock.hyperjump.io/subject\";\n\n  $: result = (async function () {\n    if (subject !== \"\") {\n      fetchStub.set(subjectUrl, subject, \"application/reference+json\");\n\n      const doc = Hyperjump.get(subjectUrl, Hyperjump.nil);\n\n      let v;\n      try {\n        v = await validate;\n      } catch (e) {}\n\n      if (v) {\n        return v(doc);\n      }\n    }\n  }());\n</script>\n\n<svelte:head>\n\t<title>Hyperjump Validation</title>\n</svelte:head>\n\n<main>\n  <h1>Hyperjump Validation</h1>\n  <div class=\"foo\">\n    <div class=\"bar\">\n      <h2>Validation</h2>\n      <textarea name=\"validation\" bind:value={validation}></textarea>\n      <pre class=\"results\">\n        {#await validate then v}\n          {#if v}\n            Valid\n          {/if}\n        {:catch error}\n          {Array.isArray(error) ? JSON.stringify(error, null, \"  \") : error}\n        {/await}\n      </pre>\n    </div>\n    <div class=\"bar\">\n      <h2>Subject</h2>\n      <textarea name=\"subject\" bind:value={subject}></textarea>\n      <pre class=\"results\">\n        {#await result then r}\n          {#if r}\n            {Validation.isValid(r) ? \"Valid\" : JSON.stringify(r, null, \"  \")}\n          {/if}\n        {:catch error}\n          {error}\n        {/await}\n      </pre>\n    </div>\n  </div>\n</main>\n\n<style>\n  .foo {\n    display: flex;\n    height: 100%;\n    width: 100%;\n  }\n\n  .bar {\n    display: flex;\n    width: 100%;\n    flex-direction: column;\n    padding: 1em;\n  }\n\n  .results {\n    border: thin solid black;\n    padding: .5em;\n    min-height: 100px;\n    overflow: scroll;\n  }\n\n  h1 {\n    margin: 1em auto;\n  }\n\n  textarea {\n    display: block;\n    height: 100%;\n    border: thin solid black;\n    min-height: 300px;\n    font-size: 16px;\n    padding: .5em;\n    margin-bottom: 1em;\n  }\n</style>\n"],"names":["fn","arity","curried","length","args","slice","call","arguments","apply","this","concat","PARAM_REGEXP","TEXT_REGEXP","TOKEN_REGEXP","QESC_REGEXP","QUOTE_REGEXP","TYPE_REGEXP","qstring","val","str","String","test","TypeError","replace","ContentType","type","parameters","Object","create","obj","string","param","params","keys","sort","i","header","getHeader","headers","getcontenttype","index","indexOf","substr","trim","toLowerCase","key","match","value","lastIndex","exec","base","relative","startsWith","_shouldAddSlash","_addSlash","baseObj","resultObject","host","path","query","protocol","protocolEndIndex","Error","substring","pathIndex","queryIndex","hashIndex","_baseParse","relativeObj","href","hash","netPath","absolutePath","relativePath","RegExp","_isAbsolute","_relativeParse","_pathResolve","resolvePath","basePath","resultString","lastIndexOf","url","pathSplit","split","resultArray","forEach","current","pop","push","join","protocolIndex","noPath","includes","noQuery","noHash","fetch","uriReference","uriFragment","isObject","Array","isArray","require$$0","construct","body","freeze","extend","doc","extras","nil","undefined","source","isDocument","contentTypeHandler","get","curry","async","contextDoc","options","result","resolvedUrl","resolveUrl","embedded","content-type","response","name","entries","text","step","Promise","all","map","list","item","filter","reduce","acc","some","a","every","_key","pipeline","fns","contentTypes","defaultHandler","contentType","contentTypeParser","parse","addContentType","handler","getContentType","json","JSON","Hyperjump","Core","append","segment","pointer","escape","toString","unescape","applySegment","ptr","jref","isEmbedded","id","stringify","$href","JsonPointer","decodeURIComponent","isHref","jrefDoc","docValue","encodeURI","global","log","Math","LN2","clz32","x","fromCharCode","Object_prototype_toString","NativeBuffer","e","NativeBufferString","prototype","NativeUint8Array","Uint8Array","usingTypedArrays","isPrototypeOf","ArrayBufferString","ArrayBuffer","decoderReplacer","encoded","codePoint","charCodeAt","leadingOnes","endPos","stringLen","TextDecoder","decode","inputArrayOrBuffer","buffer","asString","inputAs8","resultingString","len","encoderReplacer","nonAsciiChars","point","nextcode","TextEncoder","encode","inputString","encodedString","factory","exports","self","isType","null","boolean","object","array","number","numberEqual","b","abs","Number","EPSILON","jsonStringLength","compile","ast","meta","getMeta","keyword","keywordDoc","keywordUrl","node","keywords","metaAst","metaCompile","_","metaDoc","interpret","d","memo","Set","docKey","has","add","keywordValue","metaInterpret","isValid","$meta","_pointer","addKeyword","keywordDefinition","validate","keyList","native_stringify","allowUndefined","max","propVal","tipeof","toJSON","isFinite","jsonStringify","constValue","multipleOf","remainder","maximum","exclusiveMaximum","minimum","exclusiveMinimum","maxLength","minLength","pattern","HVal","items","itemDoc","tupleItems","ndx","maxItems","minItems","uniqueItems","normalizedItems","size","propertyName","propertyDoc","properties","propertyValue","propertyPattern","patternProperties","property","propertyNames","maxProperties","minProperties","required","subDoc","allOf","anyOf","oneOf","not","validation","JRef","assign","keywordDomain","error","v","r","Validation","subject","require$$1","require$$2","require$$3","require$$4","require$$5","require$$6","require$$7","require$$8","require$$9","require$$10","require$$11","require$$12","require$$13","require$$14","require$$15","require$$16","require$$17","require$$18","require$$19","require$$20","require$$21","require$$22","require$$23","require$$24","require$$25","require$$26","validationUrl","subjectUrl","fetchStub","set"],"mappings":"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"}